// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: team.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const changeTeamOwner = `-- name: ChangeTeamOwner :exec
UPDATE "team"
SET owner_id = $2,
  updated_at = now()
WHERE id = $1
RETURNING id, name, description, enabled, owner_id, created_at, updated_at, deleted_at
`

type ChangeTeamOwnerParams struct {
	ID      uuid.UUID `db:"id" json:"id"`
	OwnerID uuid.UUID `db:"owner_id" json:"owner_id"`
}

// ChangeTeamOwner changes the owner of a Team
func (q *Queries) ChangeTeamOwner(ctx context.Context, arg ChangeTeamOwnerParams) error {
	_, err := q.exec(ctx, q.changeTeamOwnerStmt, changeTeamOwner, arg.ID, arg.OwnerID)
	return err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO "team" (
    id,
    name,
    description,
    enabled,
    owner_id
)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, description, enabled, owner_id, created_at, updated_at, deleted_at
`

type CreateTeamParams struct {
	ID          uuid.UUID `db:"id" json:"id"`
	Name        string    `db:"name" json:"name"`
	Description string    `db:"description" json:"description"`
	Enabled     bool      `db:"enabled" json:"enabled"`
	OwnerID     uuid.UUID `db:"owner_id" json:"owner_id"`
}

// CreateTeam creates a new Team entry
func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (Team, error) {
	row := q.queryRow(ctx, q.createTeamStmt, createTeam,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Enabled,
		arg.OwnerID,
	)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Enabled,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteTeam = `-- name: DeleteTeam :one
DELETE FROM "team"
WHERE id = $1
RETURNING id, name, description, enabled, owner_id, created_at, updated_at, deleted_at
`

// DeleteTeam deletes a Team
func (q *Queries) DeleteTeam(ctx context.Context, id uuid.UUID) (Team, error) {
	row := q.queryRow(ctx, q.deleteTeamStmt, deleteTeam, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Enabled,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const disableTeam = `-- name: DisableTeam :exec
UPDATE "team"
SET enabled = false,
  updated_at = now()
WHERE id = $1
`

// DisableTeam sets the enabled field to false
func (q *Queries) DisableTeam(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.disableTeamStmt, disableTeam, id)
	return err
}

const enableTeam = `-- name: EnableTeam :exec
UPDATE "team"
SET enabled = true,
  updated_at = now()
WHERE id = $1
`

// EnableTeam sets the enabled field to true
func (q *Queries) EnableTeam(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.enableTeamStmt, enableTeam, id)
	return err
}

const listTeams = `-- name: ListTeams :many
SELECT id, name, description, enabled, owner_id, created_at, updated_at, deleted_at
FROM "team"
WHERE id = ANY($1::uuid [])
`

// ListTeams fetches a list of Teams by their IDs
func (q *Queries) ListTeams(ctx context.Context, ids []uuid.UUID) ([]Team, error) {
	rows, err := q.query(ctx, q.listTeamsStmt, listTeams, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Enabled,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readTeam = `-- name: ReadTeam :one
SELECT id, name, description, enabled, owner_id, created_at, updated_at, deleted_at
FROM "team"
WHERE id = $1
LIMIT 1
`

// ReadTeam fetches a single Team by ID
func (q *Queries) ReadTeam(ctx context.Context, id uuid.UUID) (Team, error) {
	row := q.queryRow(ctx, q.readTeamStmt, readTeam, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Enabled,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const readTeamByOwner = `-- name: ReadTeamByOwner :one
SELECT id, name, description, enabled, owner_id, created_at, updated_at, deleted_at
FROM "team"
WHERE owner_id = $1
`

// ReadTeamByOwner fetches a single Team by owner_id
func (q *Queries) ReadTeamByOwner(ctx context.Context, ownerID uuid.UUID) (Team, error) {
	row := q.queryRow(ctx, q.readTeamByOwnerStmt, readTeamByOwner, ownerID)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Enabled,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const softDeleteTeam = `-- name: SoftDeleteTeam :exec
UPDATE "team"
SET deleted_at = now(),
  updated_at = now()
WHERE id = $1
`

// SoftDeleteTeam sets the deleted_at timestamp to now(), indicating that the Team is deleted
func (q *Queries) SoftDeleteTeam(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.softDeleteTeamStmt, softDeleteTeam, id)
	return err
}

const unsoftDeleteTeam = `-- name: UnsoftDeleteTeam :exec
UPDATE "team"
SET soft_deleted_at = NULL,
  updated_at = now()
WHERE id = $1
`

// UnsoftDeleteTeam sets the deleted_at timestamp to NULL, indicating that the Team is not deleted
func (q *Queries) UnsoftDeleteTeam(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.unsoftDeleteTeamStmt, unsoftDeleteTeam, id)
	return err
}

const updateTeam = `-- name: UpdateTeam :one
UPDATE "team"
SET name = $2,
  description = $3,
  updated_at = now()
WHERE id = $1
RETURNING id, name, description, enabled, owner_id, created_at, updated_at, deleted_at
`

type UpdateTeamParams struct {
	ID          uuid.UUID `db:"id" json:"id"`
	Name        string    `db:"name" json:"name"`
	Description string    `db:"description" json:"description"`
}

// UpdateTeam updates the details of a Team
func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) (Team, error) {
	row := q.queryRow(ctx, q.updateTeamStmt, updateTeam, arg.ID, arg.Name, arg.Description)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Enabled,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
